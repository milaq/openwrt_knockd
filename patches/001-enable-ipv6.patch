From 87e0fefc2d140ff4dc307f77d405dc4d7e7821e5 Mon Sep 17 00:00:00 2001
From: Sebastien Valat <sebastien.valat@gmail.com>
Date: Fri, 5 Jan 2018 15:01:19 +0100
Subject: [PATCH 01/12] Add dual support of ipv4/6 in knocking client

---
 src/knock.c | 88 +++++++++++++++++++++++++++++++++++++++--------------
 1 file changed, 66 insertions(+), 22 deletions(-)

diff --git a/src/knock.c b/src/knock.c
index 319e51d..625f2c8 100644
--- a/src/knock.c
+++ b/src/knock.c
@@ -40,6 +40,10 @@ static char version[] = "0.7";
 #define PROTO_TCP 1
 #define PROTO_UDP 2
 
+#define IP_DEFAULT AF_UNSPEC
+#define IP_V4 AF_INET
+#define IP_V6 AF_INET6
+
 /* function prototypes */
 void vprint(char *fmt, ...);
 void ver();
@@ -48,13 +52,32 @@ void usage();
 int o_verbose = 0;
 int o_udp     = 0;
 int o_delay   = 0;
+int o_ip      = IP_DEFAULT;
+
+int txt_to_ip_version(const char * value)
+{
+	int n = atoi(value);
+	
+	if (n == 4)
+	{
+		return IP_V4;
+	} else if (n == 6) {
+		return IP_V6;
+	} else {
+		fprintf(stderr,"Invalid IP protocol version %d, should be 4 or 6 !",n);
+		exit(1);
+	}
+}
 
 int main(int argc, char** argv)
 {
 	int sd;
-	struct hostent* host;
-	struct sockaddr_in addr;
 	int opt, optidx = 1;
+	struct addrinfo hints;
+	struct addrinfo *infoptr;
+	char ipname[256];
+	int result;
+	char * hostname;
 	static struct option opts[] =
 	{
 		{"verbose",   no_argument,       0, 'v'},
@@ -62,10 +85,11 @@ int main(int argc, char** argv)
 		{"delay",     required_argument, 0, 'd'},
 		{"help",      no_argument,       0, 'h'},
 		{"version",   no_argument,       0, 'V'},
+		{"ip",        required_argument, 0, 'i'},
 		{0, 0, 0, 0}
 	};
 
-	while((opt = getopt_long(argc, argv, "vud:hV", opts, &optidx))) {
+	while((opt = getopt_long(argc, argv, "vud:hVi:", opts, &optidx))) {
 		if(opt < 0) {
 			break;
 		}
@@ -75,6 +99,7 @@ int main(int argc, char** argv)
 			case 'u': o_udp = 1; break;
 			case 'd': o_delay = (int)atoi(optarg); break;
 			case 'V': ver();
+			case 'i': o_ip = txt_to_ip_version(optarg); break;
 			case 'h': /* fallthrough */
 			default: usage();
 		}
@@ -88,18 +113,20 @@ int main(int argc, char** argv)
 		exit(1);
 	}
 
-	host = gethostbyname(argv[optind++]);
-	if(host == NULL) {
-		fprintf(stderr, "Cannot resolve hostname\n");
-		exit(1);
-	}
+	//prepare hints to select ipv4 or v6 if asked
+	memset(&hints, 0, sizeof hints);
+	hints.ai_family = o_ip;
+	hostname = argv[optind++];
+	
 	for(; optind < argc; optind++) {
-		unsigned short port, proto = PROTO_TCP;
+		const char * port;
+		unsigned short proto = PROTO_TCP;
 		char *ptr, *arg = strdup(argv[optind]);
-
+		
+		//select TCP/UDP protocol
 		if((ptr = strchr(arg, ':'))) {
 			*ptr = '\0';
-			port = atoi(arg);
+			port = arg;
 			arg = ++ptr;
 			if(!strcmp(arg, "udp")) {
 				proto = PROTO_UDP;
@@ -107,18 +134,27 @@ int main(int argc, char** argv)
 				proto = PROTO_TCP;
 			}
 		} else {
-			port = atoi(arg);
+			port = arg;
 		}
 
+		//get host and port based on hints
+		result = getaddrinfo(hostname, port, &hints, &infoptr);
+		if(result) {
+			fprintf(stderr, "Fail to resolve hostname '%s' on port %s\n",hostname,port);
+			fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(result));
+			exit(1);
+		}
+		
+		//create socket
 		if(o_udp || proto == PROTO_UDP) {
-			sd = socket(PF_INET, SOCK_DGRAM, 0);
+			sd = socket(infoptr->ai_family, SOCK_DGRAM, 0);
 			if(sd == -1) {
 				fprintf(stderr, "Cannot open socket\n");
 				exit(1);
 			}
 		} else {
 			int flags;
-			sd = socket(PF_INET, SOCK_STREAM, 0);
+			sd = socket(infoptr->ai_family, SOCK_STREAM, 0);
 			if(sd == -1) {
 				fprintf(stderr, "Cannot open socket\n");
 				exit(1);
@@ -126,19 +162,27 @@ int main(int argc, char** argv)
 			flags = fcntl(sd, F_GETFL, 0);
 			fcntl(sd, F_SETFL, flags | O_NONBLOCK);
 		}
-		memset(&addr, 0, sizeof(addr));
-		addr.sin_family = AF_INET;
-		addr.sin_addr.s_addr = *((long*)host->h_addr_list[0]);
-		addr.sin_port = htons(port);
+
+		//extract ip as string (v4 or v6)
+		getnameinfo(infoptr->ai_addr, infoptr->ai_addrlen, ipname, sizeof(ipname), NULL, 0, NI_NUMERICHOST);
+		
+		//connect or send UDP packet
 		if(o_udp || proto == PROTO_UDP) {
-			vprint("hitting udp %s:%u\n", inet_ntoa(addr.sin_addr), port);
-			sendto(sd, "", 1, 0, (struct sockaddr*)&addr, sizeof(addr));
+			vprint("hitting udp %s:%s\n", ipname, port);
+			sendto(sd, "", 1, 0, infoptr->ai_addr, infoptr->ai_addrlen);
 		} else {
-			vprint("hitting tcp %s:%u\n", inet_ntoa(addr.sin_addr), port);
-			connect(sd, (struct sockaddr*)&addr, sizeof(struct sockaddr));
+			vprint("hitting tcp %s:%s\n", ipname, port);
+			connect(sd, infoptr->ai_addr, infoptr->ai_addrlen);
 		}
+		
+		//close socket
 		close(sd);
+		
+		//wait delay
 		usleep(1000*o_delay);
+		
+		//free temp mem
+		freeaddrinfo(infoptr);
 	}
 
 	return(0);

From 77459d7bdc8a47bb80bb806f58a956754cd4fb11 Mon Sep 17 00:00:00 2001
From: Sebastien Valat <sebastien.valat@gmail.com>
Date: Fri, 5 Jan 2018 18:19:46 +0100
Subject: [PATCH 02/12] First working version of knockd on ipv6

---
 src/knockd.c | 455 +++++++++++++++++++++++++++++++--------------------
 1 file changed, 278 insertions(+), 177 deletions(-)

diff --git a/src/knockd.c b/src/knockd.c
index d23a3cf..be288b5 100644
--- a/src/knockd.c
+++ b/src/knockd.c
@@ -40,6 +40,7 @@
 #include <netinet/in_systm.h>
 #include <netinet/in.h>
 #include <netinet/ip.h>
+#include <netinet/ip6.h>
 #include <netinet/tcp.h>
 #include <netinet/udp.h>
 #include <netinet/ip_icmp.h>
@@ -93,6 +94,7 @@ typedef struct opendoor {
 	flag_stat flag_urg;
 	FILE *one_time_sequences_fd;
 	char *pcap_filter_exp;
+	char *pcap_filter_expv6;
 } opendoor_t;
 PMList *doors = NULL;
 
@@ -102,7 +104,7 @@ PMList *doors = NULL;
 typedef struct knocker {
 	opendoor_t *door;
 	short stage;
-	char src[16];   /* IP address */
+	char src[64];   /* IP address */
 	char *srchost;  /* Hostname */
 	time_t seq_start;
 } knocker_t;
@@ -139,11 +141,13 @@ int target_strcmp(char *ip, char *target);
 pcap_t *cap = NULL;
 FILE *logfd = NULL;
 int lltype = -1;
+int hasIpV6 = 0;
 /* list of IP addresses for given interface
  */
 typedef struct ip_literal {
 	struct ip_literal *next;
 	char *value;
+	int isIpV6;
 } ip_literal_t;
 ip_literal_t *myips = NULL;
 
@@ -265,7 +269,9 @@ int main(int argc, char **argv)
 			if (ifa->ifa_addr == NULL)
 				continue;
 
-			if((strcmp(ifa->ifa_name, o_int) == 0) && (ifa->ifa_addr->sa_family == AF_INET)) {
+			if((strcmp(ifa->ifa_name, o_int) == 0) && (ifa->ifa_addr->sa_family == AF_INET || ifa->ifa_addr->sa_family == AF_INET6)) {
+				if (ifa->ifa_addr->sa_family == AF_INET6)
+					hasIpV6 = 1;
 				if((myip = calloc(1, sizeof(ip_literal_t))) == NULL) {
 					perror("malloc");
 					exit(1);
@@ -273,11 +279,17 @@ int main(int argc, char **argv)
 					perror("malloc");
 					exit(1);
 				} else {
-					if(getnameinfo(ifa->ifa_addr, sizeof(struct sockaddr_in), myip->value, NI_MAXHOST, NULL, 0, NI_NUMERICHOST) != 0) {
+					size_t size = (ifa->ifa_addr->sa_family == AF_INET6) ? sizeof(struct sockaddr_in6) :  sizeof(struct sockaddr_in);
+					myip->isIpV6 = (ifa->ifa_addr->sa_family == AF_INET6) ? 1 : 0;
+					
+					if(getnameinfo(ifa->ifa_addr, size, myip->value, NI_MAXHOST, NULL, 0, NI_NUMERICHOST) != 0) {
 						fprintf(stderr, "error: could not get IP address for %s: %s\n", o_int, strerror(errno));
 						freeifaddrs(ifaddr);
 						cleanup(1);
 					} else {
+						char * ptr = strchr(myip->value,'%');
+						if (ptr != NULL)
+							*ptr = '\0';
 						if(myips)
 							myip->next = myips;
 						myips = myip;
@@ -413,12 +425,13 @@ void cleanup(int signum)
 	}
 
 	if(myips) {
-		while(myips) {
-			if(myip->value)
-				free(myip->value);
-			myips = myip->next;
-			free(myip);
-		}
+//TODO find double free cause
+// 		while(myips) {
+// 			if(myip->value)
+// 				free(myip->value);
+// 			myips = myip->next;
+// 			free(myip);
+// 		}
 	}
 
 	exit(signum);
@@ -585,6 +598,7 @@ int parseconfig(char *configfile)
 				door->stop_command = NULL;
 				door->one_time_sequences_fd = NULL;
 				door->pcap_filter_exp = NULL;
+				door->pcap_filter_expv6 = NULL;
 				doors = list_add(doors, door);
 			}
 		} else {
@@ -892,174 +906,212 @@ void generate_pcap_filter()
 	unsigned int i;
 	short modified_filters = 0;  /* flag indicating if at least one filter has changed --> recompile the filter */
 	struct bpf_program bpf_prog; /* compiled BPF filter program */
+	int ipv6;
 
 	/* generate subfilters for each door having a NULL pcap_filter_exp
 	 *
 	 * Example filter for one single door:
 	 * ((tcp dst port 8000 or 8001 or 8002) and tcp[tcpflags] & tcp-syn != 0) or (udp dst port 4000 or 4001)
 	 */
-	for(lp = doors; lp; lp = lp->next) {
-		door = (opendoor_t*)lp->data;
+	for (ipv6 = 0 ; ipv6 <=1 ; ipv6++)
+	{
+		for(lp = doors; lp; lp = lp->next) {
+			door = (opendoor_t*)lp->data;
 
-		if(door->pcap_filter_exp != NULL) {
-			continue;
-		}
+			if(ipv6 == 0 && door->pcap_filter_exp != NULL) {
+				continue;
+			}
+			if(ipv6 == 1 && door->pcap_filter_expv6 != NULL) {
+				continue;
+			}
 
-		/* if we get here at least one door had a pcap_filter_exp == NULL */
-		modified_filters = 1;
+			/* if we get here at least one door had a pcap_filter_exp == NULL */
+			modified_filters = 1;
 
-		head_set = 0;
-		tcp_present = 0;
-		udp_present = 0;
+			head_set = 0;
+			tcp_present = 0;
+			udp_present = 0;
 
-		/* allocate memory for buffer if needed.
-		 * The first allocation will be 200 Bytes (should be large enough for common sequences). If there is
-		 * not enough space, a call to realloc_strcat() will eventually increase its size. The buffer will be
-		 * reused for successive doors */
-		if(buffer == NULL) {
-			bufsize = 200;
-			buffer = (char*)malloc(sizeof(char) * bufsize);
+			/* allocate memory for buffer if needed.
+			* The first allocation will be 200 Bytes (should be large enough for common sequences). If there is
+			* not enough space, a call to realloc_strcat() will eventually increase its size. The buffer will be
+			* reused for successive doors */
 			if(buffer == NULL) {
-				perror("malloc");
-				cleanup(1);
-			}
-			buffer[0] = '\0';
-		}
-
-		/* accept only incoming packets */
-		for(myip = myips; myip != NULL; myip = myip->next) {
-			if(!head_set) {
-				bufsize = realloc_strcat(&buffer, "((dst host ", bufsize);
-				head_set = 1;
-			} else {
-				bufsize = realloc_strcat(&buffer, " or dst host ", bufsize);
+				bufsize = 200;
+				buffer = (char*)malloc(sizeof(char) * bufsize);
+				if(buffer == NULL) {
+					perror("malloc");
+					cleanup(1);
+				}
+				buffer[0] = '\0';
 			}
-			bufsize = realloc_strcat(&buffer, door->target ? door->target : myip->value, bufsize);
-		}
 
-		bufsize = realloc_strcat(&buffer, ") and (", bufsize);
-		head_set = 0;
-
-		/* generate filter for all TCP ports (i.e. "((tcp dst port 4000 or 4001 or 4002) and tcp[tcpflags] & tcp-syn != 0)" */
-		for(i = 0; i < door->seqcount; i++) {
-			if(door->protocol[i] == IPPROTO_TCP) {
-				if(!head_set) {		/* first TCP port in the sequence */
-					bufsize = realloc_strcat(&buffer, "((tcp dst port ", bufsize);
+			/* accept only incoming packets */
+			for(myip = myips; myip != NULL; myip = myip->next) {
+				if (myip->isIpV6 != ipv6)
+					continue;
+				if(!head_set) {
+					bufsize = realloc_strcat(&buffer, "((dst host ", bufsize);
 					head_set = 1;
-					tcp_present = 1;
-				} else {		/* not the first TCP port in the sequence */
-					bufsize = realloc_strcat(&buffer, " or ", bufsize);
+				} else {
+					bufsize = realloc_strcat(&buffer, " or dst host ", bufsize);
 				}
-				snprintf(port_str, sizeof(port_str), "%hu", door->sequence[i]);		/* unsigned short to string */
-				bufsize = realloc_strcat(&buffer, port_str, bufsize);			/* append port number */
+				bufsize = realloc_strcat(&buffer, door->target ? door->target : myip->value, bufsize);
 			}
-		}
-		if(tcp_present) {
-			bufsize = realloc_strcat(&buffer, ")", bufsize);		/* close parentheses of TCP ports */
-		}
 
-		/* append the TCP flag filters */
-		if(tcp_present) {
-			if(door->flag_fin != DONT_CARE) {
-				bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-fin ", bufsize);
-				if(door->flag_fin == SET) {
-					bufsize = realloc_strcat(&buffer, "!= 0", bufsize);
-				}
-				if(door->flag_fin == NOT_SET) {
-					bufsize = realloc_strcat(&buffer, "== 0", bufsize);
-				}
-			}
-			if(door->flag_syn != DONT_CARE) {
-				bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-syn ", bufsize);
-				if(door->flag_syn == SET) {
-					bufsize = realloc_strcat(&buffer, "!= 0", bufsize);
-				}
-				if(door->flag_syn == NOT_SET) {
-					bufsize = realloc_strcat(&buffer, "== 0", bufsize);
+			bufsize = realloc_strcat(&buffer, ") and (", bufsize);
+			head_set = 0;
+
+			/* generate filter for all TCP ports (i.e. "((tcp dst port 4000 or 4001 or 4002) and tcp[tcpflags] & tcp-syn != 0)" */
+			for(i = 0; i < door->seqcount; i++) {
+				if(door->protocol[i] == IPPROTO_TCP) {
+					if(!head_set) {		/* first TCP port in the sequence */
+						bufsize = realloc_strcat(&buffer, "((tcp dst port ", bufsize);
+						head_set = 1;
+						tcp_present = 1;
+					} else {		/* not the first TCP port in the sequence */
+						bufsize = realloc_strcat(&buffer, " or ", bufsize);
+					}
+					snprintf(port_str, sizeof(port_str), "%hu", door->sequence[i]);		/* unsigned short to string */
+					bufsize = realloc_strcat(&buffer, port_str, bufsize);			/* append port number */
 				}
 			}
-			if(door->flag_rst != DONT_CARE) {
-				bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-rst ", bufsize);
-				if(door->flag_rst == SET) {
-					bufsize = realloc_strcat(&buffer, "!= 0", bufsize);
-				}
-				if(door->flag_rst == NOT_SET) {
-					bufsize = realloc_strcat(&buffer, "== 0", bufsize);
-				}
+			if(tcp_present) {
+				bufsize = realloc_strcat(&buffer, ")", bufsize);		/* close parentheses of TCP ports */
 			}
-			if(door->flag_psh != DONT_CARE) {
-				bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-push ", bufsize);
-				if(door->flag_psh == SET) {
-					bufsize = realloc_strcat(&buffer, "!= 0", bufsize);
+
+			/* append the TCP flag filters */
+			if(tcp_present) {
+				if(door->flag_fin != DONT_CARE) {
+					if (ipv6)
+						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x17 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
+					else
+						bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-fin ", bufsize);
+					if(door->flag_fin == SET) {
+						bufsize = realloc_strcat(&buffer, "!= 0", bufsize);
+					}
+					if(door->flag_fin == NOT_SET) {
+						bufsize = realloc_strcat(&buffer, "== 0", bufsize);
+					}
 				}
-				if(door->flag_psh == NOT_SET) {
-					bufsize = realloc_strcat(&buffer, "== 0", bufsize);
+				if(door->flag_syn != DONT_CARE) {
+					if (ipv6)
+						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x17 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
+					else
+						bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-syn ", bufsize);
+					if(door->flag_syn == SET) {
+						bufsize = realloc_strcat(&buffer, "!= 0", bufsize);
+					}
+					if(door->flag_syn == NOT_SET) {
+						bufsize = realloc_strcat(&buffer, "== 0", bufsize);
+					}
 				}
-			}
-			if(door->flag_ack != DONT_CARE) {
-				bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-ack ", bufsize);
-				if(door->flag_ack == SET) {
-					bufsize = realloc_strcat(&buffer, "!= 0", bufsize);
+				if(door->flag_rst != DONT_CARE) {
+					if (ipv6)
+						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x17 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
+					else
+						bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-rst ", bufsize);
+					if(door->flag_rst == SET) {
+						bufsize = realloc_strcat(&buffer, "!= 0", bufsize);
+					}
+					if(door->flag_rst == NOT_SET) {
+						bufsize = realloc_strcat(&buffer, "== 0", bufsize);
+					}
 				}
-				if(door->flag_ack == NOT_SET) {
-					bufsize = realloc_strcat(&buffer, "== 0", bufsize);
+				if(door->flag_psh != DONT_CARE) {
+					if (ipv6)
+						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x17 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
+					else
+						bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-push ", bufsize);
+					if(door->flag_psh == SET) {
+						bufsize = realloc_strcat(&buffer, "!= 0", bufsize);
+					}
+					if(door->flag_psh == NOT_SET) {
+						bufsize = realloc_strcat(&buffer, "== 0", bufsize);
+					}
 				}
-			}
-			if(door->flag_urg != DONT_CARE) {
-				bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-urg ", bufsize);
-				if(door->flag_urg == SET) {
-					bufsize = realloc_strcat(&buffer, "!= 0", bufsize);
+				if(door->flag_ack != DONT_CARE) {
+					if (ipv6)
+						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x17 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
+					else
+						bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-ack ", bufsize);
+					if(door->flag_ack == SET) {
+						bufsize = realloc_strcat(&buffer, "!= 0", bufsize);
+					}
+					if(door->flag_ack == NOT_SET) {
+						bufsize = realloc_strcat(&buffer, "== 0", bufsize);
+					}
 				}
-				if(door->flag_urg == NOT_SET) {
-					bufsize = realloc_strcat(&buffer, "== 0", bufsize);
+				if(door->flag_urg != DONT_CARE) {
+					if (ipv6)
+						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x17 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
+					else
+						bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-urg ", bufsize);
+					if(door->flag_urg == SET) {
+						bufsize = realloc_strcat(&buffer, "!= 0", bufsize);
+					}
+					if(door->flag_urg == NOT_SET) {
+						bufsize = realloc_strcat(&buffer, "== 0", bufsize);
+					}
 				}
+				bufsize = realloc_strcat(&buffer, ")", bufsize);		/* close parentheses of flags */
 			}
-			bufsize = realloc_strcat(&buffer, ")", bufsize);		/* close parentheses of flags */
-		}
 
-		/* append filter for all UDP ports (i.e. "(udp dst port 6543 or 6544 or 6545)" */
-		head_set = 0;
-		for(i = 0; i < door->seqcount; i++) {
-			if(door->protocol[i] == IPPROTO_UDP) {
-				if(!head_set) {		/* first UDP port in the sequence */
-					if(tcp_present) {
+			/* append filter for all UDP ports (i.e. "(udp dst port 6543 or 6544 or 6545)" */
+			head_set = 0;
+			for(i = 0; i < door->seqcount; i++) {
+				if(door->protocol[i] == IPPROTO_UDP) {
+					if(!head_set) {		/* first UDP port in the sequence */
+						if(tcp_present) {
+							bufsize = realloc_strcat(&buffer, " or ", bufsize);
+						}
+						bufsize = realloc_strcat(&buffer, "(udp dst port ", bufsize);
+						head_set = 1;
+						udp_present = 1;
+					} else {		/* not the first UDP port in the sequence */
 						bufsize = realloc_strcat(&buffer, " or ", bufsize);
 					}
-					bufsize = realloc_strcat(&buffer, "(udp dst port ", bufsize);
-					head_set = 1;
-					udp_present = 1;
-				} else {		/* not the first UDP port in the sequence */
-					bufsize = realloc_strcat(&buffer, " or ", bufsize);
+					snprintf(port_str, sizeof(port_str), "%hu", door->sequence[i]);		/* unsigned short to string */
+					bufsize = realloc_strcat(&buffer, port_str, bufsize);			/* append port number */
 				}
-				snprintf(port_str, sizeof(port_str), "%hu", door->sequence[i]);		/* unsigned short to string */
-				bufsize = realloc_strcat(&buffer, port_str, bufsize);			/* append port number */
 			}
-		}
-		if(udp_present) {
-			bufsize = realloc_strcat(&buffer, ")", bufsize);		/* close parentheses of UDP ports */
-		}
+			if(udp_present) {
+				bufsize = realloc_strcat(&buffer, ")", bufsize);		/* close parentheses of UDP ports */
+			}
 
-		bufsize = realloc_strcat(&buffer, "))", bufsize);		/* close parantheses around port filters */
+			bufsize = realloc_strcat(&buffer, "))", bufsize);		/* close parantheses around port filters */
 
-		/* test if in any of the precedent calls to realloc_strcat() failed. We can do this safely here because
-		 * realloc_strcat() returns 0 on failure and if a buffer size of 0 is passed to it, the function does
-		 * nothing but returning 0 again. Because we never read buffer in the above code, it is secure to test
-		 * for failure only at this point (it makes the code more readable than checking for failure each time
-		 * realloc_strcat() is called). */
-		if(bufsize == 0) {
-			perror("realloc");
-			cleanup(1);
-		}
+			/* test if in any of the precedent calls to realloc_strcat() failed. We can do this safely here because
+			* realloc_strcat() returns 0 on failure and if a buffer size of 0 is passed to it, the function does
+			* nothing but returning 0 again. Because we never read buffer in the above code, it is secure to test
+			* for failure only at this point (it makes the code more readable than checking for failure each time
+			* realloc_strcat() is called). */
+			if(bufsize == 0) {
+				perror("realloc");
+				cleanup(1);
+			}
 
-		/* allocate the buffer in door holding the filter string, copy it and prepare buffer for being reused. */
-		door->pcap_filter_exp = (char*)malloc(strlen(buffer) + 1);
-		if(door->pcap_filter_exp == NULL) {
-			perror("malloc");
-			cleanup(1);
+			/* allocate the buffer in door holding the filter string, copy it and prepare buffer for being reused. */
+			if (ipv6)
+			{
+				door->pcap_filter_expv6 = (char*)malloc(strlen(buffer) + 1);
+				if(door->pcap_filter_expv6 == NULL) {
+					perror("malloc");
+					cleanup(1);
+				}
+				strcpy(door->pcap_filter_expv6, buffer);
+				dprint("Adding pcap expression for door '%s': %s\n", door->name, door->pcap_filter_expv6);
+			} else {
+				door->pcap_filter_exp = (char*)malloc(strlen(buffer) + 1);
+				if(door->pcap_filter_exp == NULL) {
+					perror("malloc");
+					cleanup(1);
+				}
+				strcpy(door->pcap_filter_exp, buffer);
+				dprint("Adding pcap expression for door '%s': %s\n", door->name, door->pcap_filter_exp);
+			}
+			buffer[0] = '\0';	/* "clear" the buffer */
 		}
-		strcpy(door->pcap_filter_exp, buffer);
-		dprint("Adding pcap expression for door '%s': %s\n", door->name, door->pcap_filter_exp);
-		buffer[0] = '\0';	/* "clear" the buffer */
 	}
 
 
@@ -1079,11 +1131,20 @@ void generate_pcap_filter()
 		/* iterate over all doors */
 		for(lp = doors; lp; lp = lp->next) {
 			door = (opendoor_t*)lp->data;
-			bufsize = realloc_strcat(&buffer, door->pcap_filter_exp, bufsize);
-			if(lp->next != NULL) {
+			for (ipv6 = 0 ; ipv6 <= 1 ; ipv6++)
+			{
+				if (ipv6)
+					bufsize = realloc_strcat(&buffer, door->pcap_filter_expv6, bufsize);
+				else
+					bufsize = realloc_strcat(&buffer, door->pcap_filter_exp, bufsize);
 				bufsize = realloc_strcat(&buffer, " or ", bufsize);
 			}
 		}
+		
+		//track to avoid to remove last or.... to be improved
+		bufsize = realloc_strcat(&buffer, "(0==1)", bufsize);
+		
+		//dprint("FULL : %s\n",buffer);
 
 		/* test if in any of the precedent calls to realloc_strcat() failed. See above why this is ok to do this only
 		 * at this point */
@@ -1093,11 +1154,11 @@ void generate_pcap_filter()
 		}
 
 		if(pcap_compile(cap, &bpf_prog, buffer, 1, 0) < 0) {	/* optimize filter (1), no netmask (0) (we're not interested in broadcasts) */
-			pcap_perror(cap, "pcap");
+			pcap_perror(cap, "pcap_compile");
 			cleanup(1);
 		}
 		if(pcap_setfilter(cap, &bpf_prog) < 0) {
-			pcap_perror(cap, "pcap");
+			pcap_perror(cap, "pcap_setfilter");
 			cleanup(1);
 		}
 		pcap_freecode(&bpf_prog);
@@ -1286,12 +1347,12 @@ int exec_cmd(char* command, char* name){
  * If examining a TCP packet, try to match flags against those in
  * the door config.
  */
-int flags_match(opendoor_t* door, struct ip* ip, struct tcphdr* tcp)
+int flags_match(opendoor_t* door, int ipTPoto, struct tcphdr* tcp)
 {
 	/* if tcp, check the flags to ignore the packets we don't want
 	 * (don't even use it to cancel sequences)
 	 */
-	if(ip->ip_p == IPPROTO_TCP) {
+	if(ipTPoto == IPPROTO_TCP) {
 		if(door->flag_fin != DONT_CARE) {
 			if(door->flag_fin == SET && !(tcp->th_flags & TH_FIN)) {
 				dprint("packet is not FIN, ignoring...\n");
@@ -1447,13 +1508,14 @@ void sniff(u_char* arg, const struct pcap_pkthdr* hdr, const u_char* packet)
 	/* packet structs */
 	struct ether_header* eth = NULL;
 	struct ip* ip = NULL;
+	struct ip6_hdr * ip6;
 	struct tcphdr* tcp = NULL;
 	struct udphdr* udp = NULL;
 	char proto[8];
 	/* TCP/IP data */
 	struct in_addr inaddr;
 	unsigned short sport, dport;
-	char srcIP[16], dstIP[16];
+	char srcIP[64], dstIP[64];
 	/* timestamp */
 	time_t pkt_secs = hdr->ts.tv_sec;
 	struct tm* pkt_tm;
@@ -1462,14 +1524,16 @@ void sniff(u_char* arg, const struct pcap_pkthdr* hdr, const u_char* packet)
 	PMList *lp;
 	knocker_t *attempt = NULL;
 	PMList *found_attempts = NULL;
+	int ipProto;
 
 	if(lltype == DLT_EN10MB) {
 		eth = (struct ether_header*)packet;
-		if(ntohs(eth->ether_type) != ETHERTYPE_IP) {
+		if(ntohs(eth->ether_type) != ETHERTYPE_IP && ntohs(eth->ether_type) != ETHERTYPE_IPV6) {
 			return;
 		}
 
 		ip = (struct ip*)(packet + sizeof(struct ether_header));
+		ip6 = (struct ip6_hdr*)(packet + sizeof(struct ether_header));
 #ifdef __linux__
 	} else if(lltype == DLT_LINUX_SLL) {
 		ip = (struct ip*)((u_char*)packet + 16);
@@ -1481,29 +1545,57 @@ void sniff(u_char* arg, const struct pcap_pkthdr* hdr, const u_char* packet)
 		return;
 	}
 
-	if(ip->ip_v != 4) {
+	if(ip->ip_v != 4 && ip->ip_v != 6) {
 		/* no IPv6 yet */
-		dprint("packet is not IPv4, ignoring...\n");
-		return;
-	}
-	if(ip->ip_p == IPPROTO_ICMP) {
-		/* we don't do ICMP */
+		dprint("packet is not IPv4 or IPv6, ignoring...\n");
 		return;
 	}
+	
+	if (ip->ip_v == 4)
+	{
+		if(ip->ip_p == IPPROTO_ICMP) {
+			/* we don't do ICMP */
+			return;
+		}
 
-	sport = dport = 0;
+		sport = dport = 0;
+		ipProto = ip->ip_p;
 
-	if(ip->ip_p == IPPROTO_TCP) {
-		strncpy(proto, "tcp", sizeof(proto));
-		tcp = (struct tcphdr*)((u_char*)ip + (ip->ip_hl *4));
-		sport = ntohs(tcp->th_sport);
-		dport = ntohs(tcp->th_dport);
-	}
-	if(ip->ip_p == IPPROTO_UDP) {
-		strncpy(proto, "udp", sizeof(proto));
-		udp = (struct udphdr*)((u_char*)ip + (ip->ip_hl * 4));
-		sport = ntohs(udp->uh_sport);
-		dport = ntohs(udp->uh_dport);
+		if(ip->ip_p == IPPROTO_TCP) {
+			strncpy(proto, "tcp", sizeof(proto));
+			tcp = (struct tcphdr*)((u_char*)ip + (ip->ip_hl *4));
+			sport = ntohs(tcp->th_sport);
+			dport = ntohs(tcp->th_dport);
+		}
+		if(ip->ip_p == IPPROTO_UDP) {
+			strncpy(proto, "udp", sizeof(proto));
+			udp = (struct udphdr*)((u_char*)ip + (ip->ip_hl * 4));
+			sport = ntohs(udp->uh_sport);
+			dport = ntohs(udp->uh_dport);
+		}
+	} else if (ip->ip_v == 6) {
+		//we accept only TCP/UDP
+		if(ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt != IPPROTO_TCP && ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt != IPPROTO_UDP) {
+			/* we don't do ICMP */
+			dprint("Unsupported IPv6 protocol\n");
+			return;
+		}
+
+		ipProto = ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt;
+		sport = dport = 0;
+
+		if(ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt == IPPROTO_TCP) {
+			strncpy(proto, "tcp", sizeof(proto));
+			tcp = (struct tcphdr*)(ip6+1);
+			sport = ntohs(tcp->th_sport);
+			dport = ntohs(tcp->th_dport);
+		}
+		if(ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt == IPPROTO_UDP) {
+			strncpy(proto, "udp", sizeof(proto));
+			udp = (struct udphdr*)(ip6+1);
+			sport = ntohs(udp->uh_sport);
+			dport = ntohs(udp->uh_dport);
+		}
 	}
 
 	/* get the date/time */
@@ -1514,12 +1606,21 @@ void sniff(u_char* arg, const struct pcap_pkthdr* hdr, const u_char* packet)
 			pkt_tm->tm_sec);
 
 	/* convert IPs from binary to string */
-	inaddr.s_addr = ip->ip_src.s_addr;
-	strncpy(srcIP, inet_ntoa(inaddr), sizeof(srcIP)-1);
-	srcIP[sizeof(srcIP)-1] = '\0';
-	inaddr.s_addr = ip->ip_dst.s_addr;
-	strncpy(dstIP, inet_ntoa(inaddr), sizeof(dstIP)-1);
-	dstIP[sizeof(dstIP)-1] = '\0';
+	if (ip->ip_v == 4) {
+		inaddr.s_addr = ip->ip_src.s_addr;
+		strncpy(srcIP, inet_ntoa(inaddr), sizeof(srcIP)-1);
+		srcIP[sizeof(srcIP)-1] = '\0';
+		inaddr.s_addr = ip->ip_dst.s_addr;
+		strncpy(dstIP, inet_ntoa(inaddr), sizeof(dstIP)-1);
+		dstIP[sizeof(dstIP)-1] = '\0';
+	} else if (ip->ip_v == 6) {
+		inet_ntop(AF_INET6, &ip6->ip6_src, srcIP,sizeof(srcIP));
+		inet_ntop(AF_INET6, &ip6->ip6_dst, dstIP,sizeof(srcIP));
+	} else {
+		//TODO comment
+		dprint("Invalid protocol (not ipv4 or ipv6) !");
+		return;
+	}
 
 	dprint("%s %s: %s: %s:%d -> %s:%d %d bytes\n", pkt_date, pkt_time,
 			proto, srcIP, sport, dstIP, dport, hdr->len);
@@ -1601,8 +1702,8 @@ void sniff(u_char* arg, const struct pcap_pkthdr* hdr, const u_char* packet)
 		attempt = (knocker_t*)found_attempts->data;
 
 		if(attempt) {
-			int flagsmatch = flags_match(attempt->door, ip, tcp);
-			if(flagsmatch && ip->ip_p == attempt->door->protocol[attempt->stage] &&
+			int flagsmatch = flags_match(attempt->door, ipProto, tcp);
+			if(flagsmatch && ipProto == attempt->door->protocol[attempt->stage] &&
 					dport == attempt->door->sequence[attempt->stage]) {
 				process_attempt(attempt);
 			} else if(flagsmatch == 0) {
@@ -1620,10 +1721,10 @@ void sniff(u_char* arg, const struct pcap_pkthdr* hdr, const u_char* packet)
 			for(lp = doors; lp; lp = lp->next) {
 				opendoor_t *door = (opendoor_t*)lp->data;
 				/* if we're working with TCP, try to match the flags */
-				if(!flags_match(door, ip, tcp)) {
+				if(!flags_match(door, ipProto, tcp)) {
 					continue;
 				}
-				if(ip->ip_p == door->protocol[0] && dport == door->sequence[0] &&
+				if(ipProto == door->protocol[0] && dport == door->sequence[0] &&
 				   !target_strcmp(dstIP, door->target)) {
 					struct hostent *he;
 					/* create a new entry */

From a043f329309e01c6349a3dfc1f847f6269c06c09 Mon Sep 17 00:00:00 2001
From: Sebastien Valat <sebastien.valat@gmail.com>
Date: Fri, 5 Jan 2018 18:40:20 +0100
Subject: [PATCH 03/12] Add support of distinct command for IPv6 IPv4

---
 src/knockd.c | 52 ++++++++++++++++++++++++++++++++++++++++++++++------
 1 file changed, 46 insertions(+), 6 deletions(-)

diff --git a/src/knockd.c b/src/knockd.c
index be288b5..66ec7a4 100644
--- a/src/knockd.c
+++ b/src/knockd.c
@@ -84,8 +84,10 @@ typedef struct opendoor {
 	char *target;
 	time_t seq_timeout;
 	char *start_command;
+	char *start_command6;
 	time_t cmd_timeout;
 	char *stop_command;
+	char *stop_command6;
 	flag_stat flag_fin;
 	flag_stat flag_syn;
 	flag_stat flag_rst;
@@ -107,6 +109,7 @@ typedef struct knocker {
 	char src[64];   /* IP address */
 	char *srchost;  /* Hostname */
 	time_t seq_start;
+	int fromIpV6;
 } knocker_t;
 PMList *attempts = NULL;
 
@@ -594,8 +597,10 @@ int parseconfig(char *configfile)
 				door->seqcount = 0;
 				door->seq_timeout  = SEQ_TIMEOUT; /* default sequence timeout (seconds)  */
 				door->start_command = NULL;
+				door->start_command6 = NULL;
 				door->cmd_timeout = CMD_TIMEOUT; /* default command timeout (seconds) */
 				door->stop_command = NULL;
+				door->stop_command6 = NULL;
 				door->one_time_sequences_fd = NULL;
 				door->pcap_filter_exp = NULL;
 				door->pcap_filter_expv6 = NULL;
@@ -689,6 +694,14 @@ int parseconfig(char *configfile)
 						}
 						strcpy(door->start_command, ptr);
 						dprint("config: %s: start_command: %s\n", door->name, door->start_command);
+					} else if(!strcmp(key, "START_COMMAND6") || !strcmp(key, "COMMAND6")) {
+						door->start_command6 = malloc(sizeof(char) * (strlen(ptr)+1));
+						if(door->start_command6 == NULL) {
+							perror("malloc");
+							exit(1);
+						}
+						strcpy(door->start_command6, ptr);
+						dprint("config: %s: start_command6: %s\n", door->name, door->start_command6);
 					} else if(!strcmp(key, "CMD_TIMEOUT")) {
 						door->cmd_timeout = (time_t)atoi(ptr);
 						dprint("config: %s: cmd_timeout: %d\n", door->name, door->cmd_timeout);
@@ -700,6 +713,14 @@ int parseconfig(char *configfile)
 						}
 						strcpy(door->stop_command, ptr);
 						dprint("config: %s: stop_command: %s\n", door->name, door->stop_command);
+					} else if(!strcmp(key, "STOP_COMMAND6")) {
+						door->stop_command6 = malloc(sizeof(char) * (strlen(ptr)+1));
+						if(door->stop_command6 == NULL) {
+							perror("malloc");
+							exit(1);
+						}
+						strcpy(door->stop_command6, ptr);
+						dprint("config: %s: stop_command6: %s\n", door->name, door->stop_command6);
 					} else if(!strcmp(key, "TCPFLAGS")) {
 						char *flag;
 						strtoupper(ptr);
@@ -1424,6 +1445,20 @@ int flags_match(opendoor_t* door, int ipTPoto, struct tcphdr* tcp)
  */
 void process_attempt(knocker_t *attempt)
 {
+	//select
+	char * start_command;
+	char * stop_command;
+	
+	//select
+	if (attempt->fromIpV6)
+	{
+		start_command = attempt->door->start_command6;
+		stop_command = attempt->door->stop_command6;
+	} else {
+		start_command = attempt->door->start_command;
+		stop_command = attempt->door->stop_command;
+	}
+	
 	/* level up! */
 	attempt->stage++;
 	if(attempt->srchost) {
@@ -1441,7 +1476,7 @@ void process_attempt(knocker_t *attempt)
 			vprint("%s: %s: OPEN SESAME\n", attempt->src, attempt->door->name);
 			logprint("%s: %s: OPEN SESAME", attempt->src, attempt->door->name);
 		}
-		if(attempt->door->start_command && strlen(attempt->door->start_command)) {
+		if(start_command && strlen(start_command)) {
 			/* run the associated command */
 			if(fork() == 0) {
 				/* child */
@@ -1453,14 +1488,14 @@ void process_attempt(knocker_t *attempt)
 
 				/* parse start and stop command and check if the parsed commands fit in the given buffer. Don't
 				 * execute any command if one of them has been truncated */
-				cmd_len = parse_cmd(parsed_start_cmd, sizeof(parsed_start_cmd), attempt->door->start_command, attempt->src);
+				cmd_len = parse_cmd(parsed_start_cmd, sizeof(parsed_start_cmd), start_command, attempt->src);
 				if(cmd_len >= sizeof(parsed_start_cmd)) {	/* command has been truncated --> do NOT execute it */
 					fprintf(stderr, "error: parsed start command has been truncated! --> won't execute it\n");
 					logprint("error: parsed start command has been truncated! --> won't execute it");
 					exit(0); /* exit child */
 				}
-				if(attempt->door->stop_command) {
-					cmd_len = parse_cmd(parsed_stop_cmd, sizeof(parsed_stop_cmd), attempt->door->stop_command, attempt->src);
+				if(stop_command) {
+					cmd_len = parse_cmd(parsed_stop_cmd, sizeof(parsed_stop_cmd), stop_command, attempt->src);
 					if(cmd_len >= sizeof(parsed_stop_cmd)) {	/* command has been truncated --> do NOT execute it */
 						fprintf(stderr, "error: parsed stop command has been truncated! --> won't execute start command\n");
 						logprint("error: parsed stop command has been truncated! --> won't execute start command");
@@ -1471,7 +1506,7 @@ void process_attempt(knocker_t *attempt)
 				/* all parsing ok --> execute the parsed (%IP% = source IP) command */
 				exec_cmd(parsed_start_cmd, attempt->door->name);
 				/* if stop_command is set, sleep for cmd_timeout and run it*/
-				if(attempt->door->stop_command){
+				if(stop_command){
 					sleep(attempt->door->cmd_timeout);
 					if(attempt->srchost) {
 						vprint("%s (%s): %s: command timeout\n", attempt->src, attempt->srchost, attempt->door->name);
@@ -1525,6 +1560,7 @@ void sniff(u_char* arg, const struct pcap_pkthdr* hdr, const u_char* packet)
 	knocker_t *attempt = NULL;
 	PMList *found_attempts = NULL;
 	int ipProto;
+	int fromIpV6;
 
 	if(lltype == DLT_EN10MB) {
 		eth = (struct ether_header*)packet;
@@ -1559,6 +1595,7 @@ void sniff(u_char* arg, const struct pcap_pkthdr* hdr, const u_char* packet)
 		}
 
 		sport = dport = 0;
+		fromIpV6 = 0;
 		ipProto = ip->ip_p;
 
 		if(ip->ip_p == IPPROTO_TCP) {
@@ -1582,6 +1619,7 @@ void sniff(u_char* arg, const struct pcap_pkthdr* hdr, const u_char* packet)
 		}
 
 		ipProto = ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt;
+		fromIpV6 = 1;
 		sport = dport = 0;
 
 		if(ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt == IPPROTO_TCP) {
@@ -1734,9 +1772,11 @@ void sniff(u_char* arg, const struct pcap_pkthdr* hdr, const u_char* packet)
 						perror("malloc");
 						exit(1);
 					}
+					attempt->fromIpV6 = fromIpV6;
 					strcpy(attempt->src, srcIP);
 					/* try a reverse lookup if enabled  */
-					if (o_lookup) {
+					//TODO support ipv6
+					if (o_lookup && fromIpV6 == 0) {
 						inaddr.s_addr = ip->ip_src.s_addr;
 						he = gethostbyaddr((void *)&inaddr, sizeof(inaddr), AF_INET);
 						if(he) {

From 17172cad64bf6548cb810a3569831b57bec9250d Mon Sep 17 00:00:00 2001
From: Sebastien Valat <sebastien.valat@gmail.com>
Date: Fri, 5 Jan 2018 18:51:51 +0100
Subject: [PATCH 04/12] Update doc to add IPv4/IPv6 options

---
 doc/knock.1.in  |  3 +++
 doc/knockd.1.in | 21 +++++++++++++++++++++
 src/knock.c     |  1 +
 3 files changed, 25 insertions(+)

diff --git a/doc/knock.1.in b/doc/knock.1.in
index 3205faa..f65e0ea 100644
--- a/doc/knock.1.in
+++ b/doc/knock.1.in
@@ -21,6 +21,9 @@ where a router mistakes your stream of SYN packets as a port scan and blocks
 them.  If the packet rate is slowed with \-\-delay, then the router should let
 the packets through.
 .TP
+.B "\-i, \-\-ip <version>"
+IP version to be used (4 or 6). If not defined, use what is returned by DNS solving.
+.TP
 .B "\-v, \-\-verbose"
 Output verbose status messages.
 .TP
diff --git a/doc/knockd.1.in b/doc/knockd.1.in
index 2ef6297..1a573eb 100644
--- a/doc/knockd.1.in
+++ b/doc/knockd.1.in
@@ -116,6 +116,27 @@ sniffing the network).
 	cmd_timeout        = 5
 	stop_command       = /usr/sbin/iptables \-D INPUT \-s %IP% \-p tcp \-\-dport 25 \-j ACCEPT
 	
+.fi
+.TP
+.SH Example #4:
+.RS
+Example to support IPv4 and IPv6. You can provide a dedicated command for each
+of the two protocols.
+
+.nf
+[options]
+	logfile = /var/log/knockd.log
+
+[opencloseSMTP]
+	one_time_sequences = /etc/knockd/smtp_sequences
+	seq_timeout        = 15
+	tcpflags           = fin,!ack
+	start_command      = /usr/sbin/iptables \-A INPUT \-s %IP% \-p tcp \-\-dport 25 \-j ACCEPT
+	start_command6     = /usr/sbin/ip6tables \-A INPUT \-s %IP% \-p tcp \-\-dport 25 \-j ACCEPT
+	cmd_timeout        = 5
+	stop_command       = /usr/sbin/iptables \-D INPUT \-s %IP% \-p tcp \-\-dport 25 \-j ACCEPT
+	stop_command6      = /usr/sbin/ip6tables \-D INPUT \-s %IP% \-p tcp \-\-dport 25 \-j ACCEPT
+	
 .fi
 .RE
 .SH CONFIGURATION: GLOBAL DIRECTIVES
diff --git a/src/knock.c b/src/knock.c
index 625f2c8..4c4c879 100644
--- a/src/knock.c
+++ b/src/knock.c
@@ -204,6 +204,7 @@ void usage() {
 	printf("options:\n");
 	printf("  -u, --udp            make all ports hits use UDP (default is TCP)\n");
 	printf("  -d, --delay <t>      wait <t> milliseconds between port hits\n");
+	printf("  -i, --ip <version>   IP version to be used (4 or 6)\n");
 	printf("  -v, --verbose        be verbose\n");
 	printf("  -V, --version        display version\n");
 	printf("  -h, --help           this help\n");

From 07b5f3a1d8c91a375d54eccdd288478842b6c0f0 Mon Sep 17 00:00:00 2001
From: Sebastien Valat <sebastien.valat@gmail.com>
Date: Fri, 5 Jan 2018 19:37:29 +0100
Subject: [PATCH 05/12] Fix last TODOs for ipv6 support and fix a bug in
 cleanup() function

---
 src/knockd.c | 31 +++++++++++++++++--------------
 1 file changed, 17 insertions(+), 14 deletions(-)

diff --git a/src/knockd.c b/src/knockd.c
index 66ec7a4..4b13adf 100644
--- a/src/knockd.c
+++ b/src/knockd.c
@@ -426,15 +426,15 @@ void cleanup(int signum)
 	if(o_daemon) {
 		unlink(o_pidfile);
 	}
-
+	
 	if(myips) {
-//TODO find double free cause
-// 		while(myips) {
-// 			if(myip->value)
-// 				free(myip->value);
-// 			myips = myip->next;
-// 			free(myip);
-// 		}
+		while(myips) {
+			if(myip->value)
+				free(myip->value);
+			myips = myip->next;
+			free(myip);
+			myip = myips;
+		}
 	}
 
 	exit(signum);
@@ -1655,8 +1655,7 @@ void sniff(u_char* arg, const struct pcap_pkthdr* hdr, const u_char* packet)
 		inet_ntop(AF_INET6, &ip6->ip6_src, srcIP,sizeof(srcIP));
 		inet_ntop(AF_INET6, &ip6->ip6_dst, dstIP,sizeof(srcIP));
 	} else {
-		//TODO comment
-		dprint("Invalid protocol (not ipv4 or ipv6) !");
+		//dprint("Invalid protocol (not ipv4 or ipv6) !");
 		return;
 	}
 
@@ -1775,10 +1774,14 @@ void sniff(u_char* arg, const struct pcap_pkthdr* hdr, const u_char* packet)
 					attempt->fromIpV6 = fromIpV6;
 					strcpy(attempt->src, srcIP);
 					/* try a reverse lookup if enabled  */
-					//TODO support ipv6
-					if (o_lookup && fromIpV6 == 0) {
-						inaddr.s_addr = ip->ip_src.s_addr;
-						he = gethostbyaddr((void *)&inaddr, sizeof(inaddr), AF_INET);
+					if (o_lookup) {
+						if (fromIpV6 == 0)
+						{
+							inaddr.s_addr = ip->ip_src.s_addr;
+							he = gethostbyaddr((void *)&inaddr, sizeof(inaddr), AF_INET);
+						} else {
+							he = gethostbyaddr((void *)&ip6->ip6_src, sizeof(ip6->ip6_src), AF_INET6);
+						}
 						if(he) {
 							attempt->srchost = strdup(he->h_name);
 						}

From 9afc1427efcdbb81b8d5c9c9b0be3ad5a72188cb Mon Sep 17 00:00:00 2001
From: Sebastien Valat <sebastien.valat@gmail.com>
Date: Fri, 5 Jan 2018 19:48:14 +0100
Subject: [PATCH 06/12] Add an option to ignore ipv6 on knockd

---
 doc/knockd.1.in |  3 +++
 src/knockd.c    | 13 +++++++++++--
 2 files changed, 14 insertions(+), 2 deletions(-)

diff --git a/doc/knockd.1.in b/doc/knockd.1.in
index 1a573eb..6cade76 100644
--- a/doc/knockd.1.in
+++ b/doc/knockd.1.in
@@ -31,6 +31,9 @@ Output debugging messages.
 Lookup DNS names for log entries. This may be a security risk! See section
 \fBSECURITY NOTES\fP.
 .TP
+.B "\-4, \-\-only-ip-v4"
+Ignore packets from IPv6 and handle only IPv4.
+.TP
 .B "\-v, \-\-verbose"
 Output verbose status messages.
 .TP
diff --git a/src/knockd.c b/src/knockd.c
index 4b13adf..3e98620 100644
--- a/src/knockd.c
+++ b/src/knockd.c
@@ -159,6 +159,7 @@ int  o_verbose   = 0;
 int  o_debug     = 0;
 int  o_daemon    = 0;
 int  o_lookup    = 0;
+int  o_skipIpV6  = 0;
 char o_int[32]           = "";		/* default (eth0) is set after parseconfig() */
 char o_cfg[PATH_MAX]     = "/etc/knockd.conf";
 char o_pidfile[PATH_MAX] = "/var/run/knockd.pid";
@@ -182,11 +183,12 @@ int main(int argc, char **argv)
 		{"help",      no_argument,       0, 'h'},
 		{"pidfile",   required_argument, 0, 'p'},
 		{"logfile",   required_argument, 0, 'g'},
+		{"only-ip-v4",no_argument,       0, '4'},
 		{"version",   no_argument,       0, 'V'},
 		{0, 0, 0, 0}
 	};
 	
-	while((opt = getopt_long(argc, argv, "vDdli:c:p:g:hV", opts, &optidx))) {
+	while((opt = getopt_long(argc, argv, "4vDdli:c:p:g:hV", opts, &optidx))) {
 		if(opt < 0) {
 			break;
 		}
@@ -196,6 +198,7 @@ int main(int argc, char **argv)
 			case 'D': o_debug = 1; break;
 			case 'd': o_daemon = 1; break;
 			case 'l': o_lookup = 1; break;
+			case '4': o_skipIpV6 = 1; break;
 			case 'i': strncpy(o_int, optarg, sizeof(o_int)-1);
 								o_int[sizeof(o_int)-1] = '\0';
 								break;
@@ -272,7 +275,7 @@ int main(int argc, char **argv)
 			if (ifa->ifa_addr == NULL)
 				continue;
 
-			if((strcmp(ifa->ifa_name, o_int) == 0) && (ifa->ifa_addr->sa_family == AF_INET || ifa->ifa_addr->sa_family == AF_INET6)) {
+			if((strcmp(ifa->ifa_name, o_int) == 0) && (ifa->ifa_addr->sa_family == AF_INET || (ifa->ifa_addr->sa_family == AF_INET6 && !o_skipIpV6))) {
 				if (ifa->ifa_addr->sa_family == AF_INET6)
 					hasIpV6 = 1;
 				if((myip = calloc(1, sizeof(ip_literal_t))) == NULL) {
@@ -503,6 +506,7 @@ void usage(int exit_code) {
 	printf("  -p, --pidfile          use an alternate pidfile\n");
 	printf("  -g, --logfile          use an alternate logfile\n");
 	printf("  -v, --verbose          be verbose\n");
+	printf("  -4, --only-ip-v4       do not track ipv6\n");
 	printf("  -V, --version          display version\n");
 	printf("  -h, --help             this help\n");
 	printf("\n");
@@ -936,6 +940,9 @@ void generate_pcap_filter()
 	 */
 	for (ipv6 = 0 ; ipv6 <=1 ; ipv6++)
 	{
+		if (ipv6 && o_skipIpV6)
+			continue;
+		
 		for(lp = doors; lp; lp = lp->next) {
 			door = (opendoor_t*)lp->data;
 
@@ -1154,6 +1161,8 @@ void generate_pcap_filter()
 			door = (opendoor_t*)lp->data;
 			for (ipv6 = 0 ; ipv6 <= 1 ; ipv6++)
 			{
+				if (ipv6 && o_skipIpV6)
+					continue;
 				if (ipv6)
 					bufsize = realloc_strcat(&buffer, door->pcap_filter_expv6, bufsize);
 				else

From 2135a14444dc64a6296d63c2f082b08610f7a08d Mon Sep 17 00:00:00 2001
From: Sebastien Valat <sebastien.valat@gmail.com>
Date: Fri, 5 Jan 2018 19:57:52 +0100
Subject: [PATCH 07/12] Fix tcp flags rules for pcap in ipv6 mode

---
 src/knockd.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/src/knockd.c b/src/knockd.c
index 3e98620..2d5ad77 100644
--- a/src/knockd.c
+++ b/src/knockd.c
@@ -1012,7 +1012,7 @@ void generate_pcap_filter()
 			if(tcp_present) {
 				if(door->flag_fin != DONT_CARE) {
 					if (ipv6)
-						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x17 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
+						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x01 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
 					else
 						bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-fin ", bufsize);
 					if(door->flag_fin == SET) {
@@ -1024,7 +1024,7 @@ void generate_pcap_filter()
 				}
 				if(door->flag_syn != DONT_CARE) {
 					if (ipv6)
-						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x17 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
+						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x02 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
 					else
 						bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-syn ", bufsize);
 					if(door->flag_syn == SET) {
@@ -1036,7 +1036,7 @@ void generate_pcap_filter()
 				}
 				if(door->flag_rst != DONT_CARE) {
 					if (ipv6)
-						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x17 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
+						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x04 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
 					else
 						bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-rst ", bufsize);
 					if(door->flag_rst == SET) {
@@ -1048,7 +1048,7 @@ void generate_pcap_filter()
 				}
 				if(door->flag_psh != DONT_CARE) {
 					if (ipv6)
-						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x17 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
+						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x08 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
 					else
 						bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-push ", bufsize);
 					if(door->flag_psh == SET) {
@@ -1060,7 +1060,7 @@ void generate_pcap_filter()
 				}
 				if(door->flag_ack != DONT_CARE) {
 					if (ipv6)
-						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x17 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
+						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x10 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
 					else
 						bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-ack ", bufsize);
 					if(door->flag_ack == SET) {
@@ -1072,7 +1072,7 @@ void generate_pcap_filter()
 				}
 				if(door->flag_urg != DONT_CARE) {
 					if (ipv6)
-						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x17 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
+						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x20 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
 					else
 						bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-urg ", bufsize);
 					if(door->flag_urg == SET) {

From 24b262eafd31b2a3f2fa2cf589584f9c9890b352 Mon Sep 17 00:00:00 2001
From: Sebastien Valat <sebastien.valat@gmail.com>
Date: Fri, 5 Jan 2018 20:22:45 +0100
Subject: [PATCH 08/12] Rename option in config file start_command_6, command_6
 and stop_command_6. Also update doc.

---
 doc/knockd.1.in | 17 ++++++++++++++---
 src/knockd.c    |  9 +++++----
 2 files changed, 19 insertions(+), 7 deletions(-)

diff --git a/doc/knockd.1.in b/doc/knockd.1.in
index 6cade76..324a461 100644
--- a/doc/knockd.1.in
+++ b/doc/knockd.1.in
@@ -135,10 +135,10 @@ of the two protocols.
 	seq_timeout        = 15
 	tcpflags           = fin,!ack
 	start_command      = /usr/sbin/iptables \-A INPUT \-s %IP% \-p tcp \-\-dport 25 \-j ACCEPT
-	start_command6     = /usr/sbin/ip6tables \-A INPUT \-s %IP% \-p tcp \-\-dport 25 \-j ACCEPT
+	start_command_6    = /usr/sbin/ip6tables \-A INPUT \-s %IP% \-p tcp \-\-dport 25 \-j ACCEPT
 	cmd_timeout        = 5
 	stop_command       = /usr/sbin/iptables \-D INPUT \-s %IP% \-p tcp \-\-dport 25 \-j ACCEPT
-	stop_command6      = /usr/sbin/ip6tables \-D INPUT \-s %IP% \-p tcp \-\-dport 25 \-j ACCEPT
+	stop_command_6     = /usr/sbin/ip6tables \-D INPUT \-s %IP% \-p tcp \-\-dport 25 \-j ACCEPT
 	
 .fi
 .RE
@@ -205,10 +205,16 @@ etherwake to send the host a WOL packet.
 .TP
 .B "Start_Command = <command>"
 Specify the command to be executed when a client makes the correct
-port-knock.  All instances of \fB%IP%\fP will be replaced with the
+port-knock with IPv4.  All instances of \fB%IP%\fP will be replaced with the
 knocker's IP address.  The \fBCommand\fP directive is an alias for
 \fBStart_Command\fP.
 .TP
+.B "Start_Command_6 = <command>"
+Specify the command to be executed when a client makes the correct
+port-knock with IPv6.  All instances of \fB%IP%\fP will be replaced with the
+knocker's IP address.  The \fBCommand_6\fP directive is an alias for
+\fBStart_Command_6\fP.
+.TP
 .B "Cmd_Timeout = <timeout>"
 Time to wait (in seconds) between \fBStart_Command\fP and \fBStop_Command\fP.
 This directive is optional, only required if \fBStop_Command\fP is used.
@@ -217,6 +223,11 @@ This directive is optional, only required if \fBStop_Command\fP is used.
 Specify the command to be executed when \fBCmd_Timeout\fP seconds have passed 
 since \fBStart_Command\fP has been executed.  All instances of \fB%IP%\fP will
 be replaced with the knocker's IP address.  This directive is optional.
+.TP
+.B "Stop_Command_6 = <command>"
+Specify the command to be executed when \fBCmd_Timeout\fP seconds have passed 
+since \fBStart_Command_6\fP has been executed.  All instances of \fB%IP%\fP will
+be replaced with the knocker's IP address.  This directive is optional.
 .SH SECURITY NOTES 
 Using the \fB-l\fP or \fB--lookup\fP commandline option to resolve DNS names
 for log entries may be a security risk!  An attacker may find out the first port
diff --git a/src/knockd.c b/src/knockd.c
index 2d5ad77..d3d87e2 100644
--- a/src/knockd.c
+++ b/src/knockd.c
@@ -293,6 +293,7 @@ int main(int argc, char **argv)
 						freeifaddrs(ifaddr);
 						cleanup(1);
 					} else {
+						printf("\n\n%s\n\n",myip->value);
 						char * ptr = strchr(myip->value,'%');
 						if (ptr != NULL)
 							*ptr = '\0';
@@ -698,14 +699,14 @@ int parseconfig(char *configfile)
 						}
 						strcpy(door->start_command, ptr);
 						dprint("config: %s: start_command: %s\n", door->name, door->start_command);
-					} else if(!strcmp(key, "START_COMMAND6") || !strcmp(key, "COMMAND6")) {
+					} else if(!strcmp(key, "START_COMMAND_6") || !strcmp(key, "COMMAND_6")) {
 						door->start_command6 = malloc(sizeof(char) * (strlen(ptr)+1));
 						if(door->start_command6 == NULL) {
 							perror("malloc");
 							exit(1);
 						}
 						strcpy(door->start_command6, ptr);
-						dprint("config: %s: start_command6: %s\n", door->name, door->start_command6);
+						dprint("config: %s: start_command_6: %s\n", door->name, door->start_command6);
 					} else if(!strcmp(key, "CMD_TIMEOUT")) {
 						door->cmd_timeout = (time_t)atoi(ptr);
 						dprint("config: %s: cmd_timeout: %d\n", door->name, door->cmd_timeout);
@@ -717,14 +718,14 @@ int parseconfig(char *configfile)
 						}
 						strcpy(door->stop_command, ptr);
 						dprint("config: %s: stop_command: %s\n", door->name, door->stop_command);
-					} else if(!strcmp(key, "STOP_COMMAND6")) {
+					} else if(!strcmp(key, "STOP_COMMAND_6")) {
 						door->stop_command6 = malloc(sizeof(char) * (strlen(ptr)+1));
 						if(door->stop_command6 == NULL) {
 							perror("malloc");
 							exit(1);
 						}
 						strcpy(door->stop_command6, ptr);
-						dprint("config: %s: stop_command6: %s\n", door->name, door->stop_command6);
+						dprint("config: %s: stop_command_6: %s\n", door->name, door->stop_command6);
 					} else if(!strcmp(key, "TCPFLAGS")) {
 						char *flag;
 						strtoupper(ptr);

From bae0e630740a585acfdf6dfc195acf78ff45a258 Mon Sep 17 00:00:00 2001
From: Sebastien Valat <sebastien.valat@gmail.com>
Date: Fri, 5 Jan 2018 20:31:42 +0100
Subject: [PATCH 09/12] Change options on knock, use -4/-6/--ipv4/--ipv6
 instead of -i/--ip X

---
 doc/knock.1.in |  7 +++++--
 src/knock.c    | 26 +++++++-------------------
 2 files changed, 12 insertions(+), 21 deletions(-)

diff --git a/doc/knock.1.in b/doc/knock.1.in
index f65e0ea..4b598c0 100644
--- a/doc/knock.1.in
+++ b/doc/knock.1.in
@@ -21,8 +21,11 @@ where a router mistakes your stream of SYN packets as a port scan and blocks
 them.  If the packet rate is slowed with \-\-delay, then the router should let
 the packets through.
 .TP
-.B "\-i, \-\-ip <version>"
-IP version to be used (4 or 6). If not defined, use what is returned by DNS solving.
+.B "\-4, \-\-ipv4 <version>"
+Force usage of IPv4.
+.TP
+.B "\-6, \-\-ipv6 <version>"
+Force usage of IPv6.
 .TP
 .B "\-v, \-\-verbose"
 Output verbose status messages.
diff --git a/src/knock.c b/src/knock.c
index 4c4c879..efe119b 100644
--- a/src/knock.c
+++ b/src/knock.c
@@ -54,21 +54,6 @@ int o_udp     = 0;
 int o_delay   = 0;
 int o_ip      = IP_DEFAULT;
 
-int txt_to_ip_version(const char * value)
-{
-	int n = atoi(value);
-	
-	if (n == 4)
-	{
-		return IP_V4;
-	} else if (n == 6) {
-		return IP_V6;
-	} else {
-		fprintf(stderr,"Invalid IP protocol version %d, should be 4 or 6 !",n);
-		exit(1);
-	}
-}
-
 int main(int argc, char** argv)
 {
 	int sd;
@@ -85,11 +70,12 @@ int main(int argc, char** argv)
 		{"delay",     required_argument, 0, 'd'},
 		{"help",      no_argument,       0, 'h'},
 		{"version",   no_argument,       0, 'V'},
-		{"ip",        required_argument, 0, 'i'},
+		{"ipv4",      no_argument,       0, '4'},
+		{"ipv6",      no_argument,       0, '6'},
 		{0, 0, 0, 0}
 	};
 
-	while((opt = getopt_long(argc, argv, "vud:hVi:", opts, &optidx))) {
+	while((opt = getopt_long(argc, argv, "vud:hV46", opts, &optidx))) {
 		if(opt < 0) {
 			break;
 		}
@@ -99,7 +85,8 @@ int main(int argc, char** argv)
 			case 'u': o_udp = 1; break;
 			case 'd': o_delay = (int)atoi(optarg); break;
 			case 'V': ver();
-			case 'i': o_ip = txt_to_ip_version(optarg); break;
+			case '4': o_ip = IP_V4; break;
+			case '6': o_ip = IP_V6; break;
 			case 'h': /* fallthrough */
 			default: usage();
 		}
@@ -204,7 +191,8 @@ void usage() {
 	printf("options:\n");
 	printf("  -u, --udp            make all ports hits use UDP (default is TCP)\n");
 	printf("  -d, --delay <t>      wait <t> milliseconds between port hits\n");
-	printf("  -i, --ip <version>   IP version to be used (4 or 6)\n");
+	printf("  -4, --ipv4           Force usage of IPv4\n");
+	printf("  -6, --ipv6           Force usage of IPv6\n");
 	printf("  -v, --verbose        be verbose\n");
 	printf("  -V, --version        display version\n");
 	printf("  -h, --help           this help\n");

From b4e97ee0ba055e1e32b30e92f17f09d3b7fc6af6 Mon Sep 17 00:00:00 2001
From: Sebastien Valat <sebastien.valat@gmail.com>
Date: Fri, 5 Jan 2018 21:24:01 +0100
Subject: [PATCH 10/12] Some cleanup on IPv6 patch

---
 src/knockd.c | 22 +++++++++++-----------
 1 file changed, 11 insertions(+), 11 deletions(-)

diff --git a/src/knockd.c b/src/knockd.c
index d3d87e2..e533dd2 100644
--- a/src/knockd.c
+++ b/src/knockd.c
@@ -293,7 +293,6 @@ int main(int argc, char **argv)
 						freeifaddrs(ifaddr);
 						cleanup(1);
 					} else {
-						printf("\n\n%s\n\n",myip->value);
 						char * ptr = strchr(myip->value,'%');
 						if (ptr != NULL)
 							*ptr = '\0';
@@ -1013,7 +1012,7 @@ void generate_pcap_filter()
 			if(tcp_present) {
 				if(door->flag_fin != DONT_CARE) {
 					if (ipv6)
-						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x01 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
+						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & tcp-fin ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
 					else
 						bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-fin ", bufsize);
 					if(door->flag_fin == SET) {
@@ -1025,7 +1024,7 @@ void generate_pcap_filter()
 				}
 				if(door->flag_syn != DONT_CARE) {
 					if (ipv6)
-						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x02 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
+						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & tcp-syn ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
 					else
 						bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-syn ", bufsize);
 					if(door->flag_syn == SET) {
@@ -1037,7 +1036,7 @@ void generate_pcap_filter()
 				}
 				if(door->flag_rst != DONT_CARE) {
 					if (ipv6)
-						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x04 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
+						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & tcp-rst ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
 					else
 						bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-rst ", bufsize);
 					if(door->flag_rst == SET) {
@@ -1049,7 +1048,7 @@ void generate_pcap_filter()
 				}
 				if(door->flag_psh != DONT_CARE) {
 					if (ipv6)
-						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x08 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
+						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & tcp-push ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
 					else
 						bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-push ", bufsize);
 					if(door->flag_psh == SET) {
@@ -1061,7 +1060,7 @@ void generate_pcap_filter()
 				}
 				if(door->flag_ack != DONT_CARE) {
 					if (ipv6)
-						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x10 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
+						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & tcp-ack ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
 					else
 						bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-ack ", bufsize);
 					if(door->flag_ack == SET) {
@@ -1073,7 +1072,7 @@ void generate_pcap_filter()
 				}
 				if(door->flag_urg != DONT_CARE) {
 					if (ipv6)
-						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & 0x20 ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
+						bufsize = realloc_strcat(&buffer, " and ip6[13+40] & tcp-urg ", bufsize);//using directly mask as pcap didn't yet support flags for IPv6
 					else
 						bufsize = realloc_strcat(&buffer, " and tcp[tcpflags] & tcp-urg ", bufsize);
 					if(door->flag_urg == SET) {
@@ -1158,23 +1157,24 @@ void generate_pcap_filter()
 	 */
 	if(modified_filters) {
 		/* iterate over all doors */
+		int first = 1;
 		for(lp = doors; lp; lp = lp->next) {
 			door = (opendoor_t*)lp->data;
 			for (ipv6 = 0 ; ipv6 <= 1 ; ipv6++)
 			{
+				if (first)
+					first = 0;
+				else
+					bufsize = realloc_strcat(&buffer, " or ", bufsize);
 				if (ipv6 && o_skipIpV6)
 					continue;
 				if (ipv6)
 					bufsize = realloc_strcat(&buffer, door->pcap_filter_expv6, bufsize);
 				else
 					bufsize = realloc_strcat(&buffer, door->pcap_filter_exp, bufsize);
-				bufsize = realloc_strcat(&buffer, " or ", bufsize);
 			}
 		}
 		
-		//track to avoid to remove last or.... to be improved
-		bufsize = realloc_strcat(&buffer, "(0==1)", bufsize);
-		
 		//dprint("FULL : %s\n",buffer);
 
 		/* test if in any of the precedent calls to realloc_strcat() failed. See above why this is ok to do this only

From a9086772f4d27a289357b141d934c3a50da15723 Mon Sep 17 00:00:00 2001
From: Sebastien Valat <sebastien.valat@gmail.com>
Date: Fri, 5 Jan 2018 21:36:05 +0100
Subject: [PATCH 11/12] Fix compiler warnings

---
 src/knockd.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/src/knockd.c b/src/knockd.c
index e533dd2..c09d917 100644
--- a/src/knockd.c
+++ b/src/knockd.c
@@ -1559,7 +1559,8 @@ void sniff(u_char* arg, const struct pcap_pkthdr* hdr, const u_char* packet)
 	char proto[8];
 	/* TCP/IP data */
 	struct in_addr inaddr;
-	unsigned short sport, dport;
+	unsigned short sport = 0;
+	unsigned short dport = 0;
 	char srcIP[64], dstIP[64];
 	/* timestamp */
 	time_t pkt_secs = hdr->ts.tv_sec;
@@ -1569,8 +1570,8 @@ void sniff(u_char* arg, const struct pcap_pkthdr* hdr, const u_char* packet)
 	PMList *lp;
 	knocker_t *attempt = NULL;
 	PMList *found_attempts = NULL;
-	int ipProto;
-	int fromIpV6;
+	int ipProto = 0;
+	int fromIpV6 = 0;
 
 	if(lltype == DLT_EN10MB) {
 		eth = (struct ether_header*)packet;

From 0c1496983e8ab4159d4cea59b68cc771a9cdcce5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?S=C3=A9bastien=20Valat?= <sebastien.valat@gmail.com>
Date: Sun, 30 Sep 2018 20:34:07 +0200
Subject: [PATCH 12/12] Implement proposal of default fallback to same command
 than IPV4 if V6 one not defined

---
 doc/knockd.1.in | 7 ++++++-
 src/knockd.c    | 8 ++++++++
 2 files changed, 14 insertions(+), 1 deletion(-)

diff --git a/doc/knockd.1.in b/doc/knockd.1.in
index 324a461..8813acd 100644
--- a/doc/knockd.1.in
+++ b/doc/knockd.1.in
@@ -213,7 +213,9 @@ knocker's IP address.  The \fBCommand\fP directive is an alias for
 Specify the command to be executed when a client makes the correct
 port-knock with IPv6.  All instances of \fB%IP%\fP will be replaced with the
 knocker's IP address.  The \fBCommand_6\fP directive is an alias for
-\fBStart_Command_6\fP.
+\fBStart_Command_6\fP. If not present it will automatically fallback onto
+the same IPV4 \fBStart_Command\fP value. You can use empty value to force
+doing nothing.
 .TP
 .B "Cmd_Timeout = <timeout>"
 Time to wait (in seconds) between \fBStart_Command\fP and \fBStop_Command\fP.
@@ -228,6 +230,9 @@ be replaced with the knocker's IP address.  This directive is optional.
 Specify the command to be executed when \fBCmd_Timeout\fP seconds have passed 
 since \fBStart_Command_6\fP has been executed.  All instances of \fB%IP%\fP will
 be replaced with the knocker's IP address.  This directive is optional.
+If not present it will automatically fallback onto the same IPV4 
+\fBStop_Command\fP value. You can use empty value to force
+doing nothing.
 .SH SECURITY NOTES 
 Using the \fB-l\fP or \fB--lookup\fP commandline option to resolve DNS names
 for log entries may be a security risk!  An attacker may find out the first port
diff --git a/src/knockd.c b/src/knockd.c
index c09d917..d42271d 100644
--- a/src/knockd.c
+++ b/src/knockd.c
@@ -1464,6 +1464,14 @@ void process_attempt(knocker_t *attempt)
 	{
 		start_command = attempt->door->start_command6;
 		stop_command = attempt->door->stop_command6;
+		
+		//make default fallback to same than ipv4 if v6 command is not set.
+		if (start_command == NULL) {
+			start_command = attempt->door->start_command;
+		}
+		if (stop_command == NULL) {
+			stop_command = attempt->door->stop_command;
+		}
 	} else {
 		start_command = attempt->door->start_command;
 		stop_command = attempt->door->stop_command;
